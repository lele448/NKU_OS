# lab0.5

# 练习1：使用GDB验证启动流程

## 一.实验过程

> ***为了熟悉使用qemu和gdb进行调试工作,使用gdb调试QEMU模拟的RISC-V计算机加电开始运行到执行应用程序的第一条指令（即跳转到0x80200000）这个阶段的执行过程，说明RISC-V硬件加电后的几条指令在哪里？完成了哪些功能？要求在报告中简要写出练习过程和回答。***

通过阅读lab0.5部分的实验资料和查询可知模拟的RISC-V计算机加电开始运行到执行应用程序的第一条指令（即跳转到0x80200000）这个阶段的执行过程可被分为三部分：

1. ***复位***

2. ***加载OpenSBI.bin***

3. **加载内核镜像 os.bin** 

   即在 Qemu 开始执行任何指令之前，首先会完成复位，然后两个文件将被加载到 Qemu 的物理内存中：即作为 bootloader 的 OpenSBI.bin 被加载到物理内存以物理地址 0x80000000 开头的区域上，同时内核镜像 os.bin 被加载到以物理地址 0x80200000 开头的区域上

### 步骤一：复位

打开实验代码文件，选择lab0，查看makefile文件，可以看到：

![img](file:///C:\Users\小谢\AppData\Local\Temp\ksohtml27040\wps1.jpg)

打开终端，输入：make gdb，那么 make gdb 就会执行以上这条命令，启动 GDB，并连接到在 localhost:1234 上运行的 QEMU。

![img](file:///C:\Users\小谢\AppData\Local\Temp\ksohtml27040\wps2.jpg)

上图的最后一行可以看到当前执行位置在地址0x0000000000001000，我们可以知道QEMU模拟的这款riscv处理器的复位地址是0x1000（从此处开始执行复位代码），而不是0x80000000。复位代码主要是将计算机系统的各个组件（包括处理器、内存、设备等）置于初始状态，并且会启动Bootloader，在这里QEMU的复位代码指定加载Bootloader的位置为0x80000000，Bootloader将加载操作系统内核并启动操作系统的执行。

然后输入：x/10i $pc，查看即将执行的10条汇编指令。

![img](file:///C:\Users\小谢\AppData\Local\Temp\ksohtml27040\wps3.jpg)

***0x1000:	auipc	t0,0x0**   	#auipc指令用于生成一个相对地址，将当前程序计数器（PC）的高20位存入寄存器t0，低12位设为0*

  ***0x1004:	addi	a1,t0,32**   	#a1=t0+32*

  ***0x1008:	csrr	a0,mhartid**	#从mhartid寄存器读取值并存入寄存器a0*

  ***0x100c:	ld	t0,24(t0)**		#将t0+24处的数据加载到t0寄存器中*

  ***0x1010:	jr	t0**			#跳转到t0寄存器所指向的地址*

  ***0x1014:	unimp**              		#表示未实现指令*

  ***0x1016:	unimp***

  ***0x1018:	unimp***

  ***0x101a:	0x8000** 			#立即数*

  ***0x101c:	unimp***

以上便是即将执行的10条汇编指令，即RISC-V计算机加电后的指令。



### 步骤二：加载OpenSBI.bin

bootloader 的 OpenSBI.bin 会被加载到物理内存以物理地址 0x80000000 开头的区域上，可以通过”x/10i 0x80000000 “查看 0x80000000 处的10条汇编指令

![img](file:///C:\Users\小谢\AppData\Local\Temp\ksohtml27040\wps4.jpg)

 **0x80000000:	csrr	a6,mhartid** 		*#从mhartid寄存器读取值并存入寄存器a6*

  **0x80000004:	bgtz	a6,0x80000108** 		*#如果寄存器a6的值大于零，则跳转到地址0x80000108*

  **0x80000008:	auipc	t0,0x0** 		*#同0x1000处的汇编命令，将当前PC的高20位存入寄存器t0，低12位设为0*

  **0x8000000c:	addi	t0,t0,1032** 		*#t0=t0+1032*

  **0x80000010:	auipc	t1,0x0** 		*#将当前PC的高20位存入寄存器t1，为接下来的操作准备另一个地址*

  **0x80000014:	addi	t1,t1,-16** 		*#t1=t1-16*

  **0x80000018:	sd	t1,0(t0)**		 *#将t1寄存器存储的值放到以t0为基地址的内存地址中*

  **0x8000001c:	auipc	t0,0x0** 		*#再次将当前PC的高20位存入t0*

  **0x80000020:	addi	t0,t0,1020** 		*#t0=t0+1020*

  **0x80000024:	ld	t0,0(t0)**		 *#从以t0为基地址的内存中加载数据到t0*

这些指令整体目的是初始化和配置当前硬件线程的信息，同时准备和管理内存中的数据。

还可以使用命令”x/10xw 0x80000000 ”查看0x80000000 处的10条数据，格式为16进制32bit。

![img](file:///C:\Users\小谢\AppData\Local\Temp\ksohtml27040\wps5.jpg)

### 步骤三：**加载内核镜像 os.bin** 

为了正确地和上一阶段的 OpenSBI 对接，我们需要保证内核的第一条指令位于物理地址 0x80200000 处，因为这里的代码是地址相关的，这个地址是由处理器，即Qemu指定的。为此，我们需要将内核镜像预先加载到 Qemu 物理内存以地址 0x80200000 开头的区域上。一旦 CPU 开始执行内核的第一条指令，证明计算机的控制权已经被移交给我们的内核。

所以我们使用命令”break *0x80200000”在0x80200000处设置断点，然后使用命令”continue”使执行直到碰到断点，然后再输入”x/10i $pc”查看其附近的10条汇编代码信息：

![img](file:///C:\Users\小谢\AppData\Local\Temp\ksohtml27040\wps6.jpg)

 **0x80200000 <kern_entry>:	auipc	sp,0x3** *		<u>#将当前程序计数器（PC）的高20位存入寄存器 sp，低12位设为0，并加上0x3*</u>

  **0x80200004 <kern_entry+4>:	mv	sp,sp** 		*<u>#将寄存器 sp 的值复制到 sp</u>*

  **0x80200008 <kern_entry+8>:	j	0x8020000a <kern_init>** 		*<u>#无条件跳转到地址 0x8020000a</u>*

  **0x8020000a <kern_init>:	auipc	a0,0x3**  		*<u>#将当前程序计数器（PC）的高20位存入寄存器 sp，低12位设为0，并加上0x3</u>*

  **0x8020000e <kern_init+4>:	addi	a0,a0,-2** 		*<u>#a0=a0-2</u>*

  **0x80200012 <kern_init+8>:	auipc	a2,0x3** 		*<u>#将当前程序计数器（PC）的高20位存入寄存器 sp，低12位设为0，并加上0x3</u>*

  **0x80200016 <kern_init+12>:	addi	a2,a2,-10** 		*<u>#a2=a2-10</u>*

  **0x8020001a <kern_init+16>:	addi	sp,sp,-16** 		*<u>#sp=sp-16,将堆栈指针 sp 的值减去16，分配堆栈空间。</u>*

  **0x8020001c <kern_init+18>:	li	a1,0**		 *<u>#将立即数0加载到寄存器 a1</u>*

  **0x8020001e <kern_init+20>:	sub	a2,a2,a0** 		*<u>#a2=a2-a0</u>*

这些指令主要用于初始化内核环境，包括设置堆栈指针、准备变量和内存地址，以及为即将进行的操作分配必要的空间。

而且可以观察到这段汇编代码的不同，<kern_entry>表示内核的入口点，<kern_entry+4> 表示在 kern_entry 的基础上向后偏移4字节，即这是 kern_entry 函数的第二条指令。所以"  0x80200008 <kern_entry+8>:	j	0x8020000a <kern_init> "表示从kern_entry+8跳转到kern_init。



## 知识点

**`la sp, bootstacktop`**：加载内核栈顶地址到寄存器 `sp` 中。`la` 指令用于加载地址，`bootstacktop` 是定义的栈顶位置，**初始化时将 `sp` 设置为这个位置。**

- 这意味着当内核启动时，系统将使用 `bootstacktop` 作为栈顶，内核栈从高地址向低地址增长。

- 在内核启动时，设置好内核栈（`bootstacktop`）并跳转到内核初始化函数 `kern_init`。

